# 摘要：
记录了开发的心得。


# 最后优化：


task 用法：留给regfile 初始化


``` verilog
\\ 计划用task实现、
 // 存储器初始化（示例）
    initial begin
        $readmemh("code.txt", regArr_im); // 从文件加载指令
    end
```

Extender


~~infetch , 感觉 aluzero 有点多余。~~

学习git 切换版本。
新的插件。快速加入注释。
select_aluPerformance 从add sub的opcode看出全部是有符号的加减啊。

## 几个复位信号的命名
rst_regFile
rst_dataMem
rst_im
rst_pc

使用NPC处理Jump， beq的extend


# verilog语法，技巧
输入类型一定是wire
输出类型可以是reg。 
testbench, 输入常为reg 输出常是wire
lw sw 1KB 使用 256 * 32 最好

assign 用法：
不能用在block（if else, always）
用于给wire 且是 output赋值 中间wire变量由组合电路驱动不需要用assign

## 系统命令
`dumpfile` 告诉仿真器保存波形文件的文件名. 用于创建vcd文件。
`dumpvar` 指定仿真时写进vcd波形文件的信号。决定把那些信号写入vcd file.这将是你在gtkwave看到的信号。 

`$dumpvars(0, [top_module_name]);` //`top_module_name`可以是顶层模块名，如果你只是测试你写的某一个子模块，比如`ins_fetch`下含：`instructionMemory`, `PC`, `NPC`三个子模块。那么`top_module_name`就写`ins_fetch`。总之，顶层的，这样会把所有的信号囊括进来。
- 数字0表示层级，不仅关注顶层模块的信号，还会包含所有的子模块、子子模块....的信号。


## 文件名常识
.vcd file  gtkwave /path/to/vcdfile
.vvp file  iverilog编译产物，放在/build中.  
vcd file is generated by vvp command from vvp file

# 自动化 习惯
1. Makefile比task.json正规。因此，发布包含Makefile会更加正规。 当然，也可以发布task.json




# top module 实例化
只要不是input中存在的，就要定义。而且是wire类型

# testbench 实例化
unt的输入需要用reg类型提前声明。
unt的输出用wire类型提前声明。
