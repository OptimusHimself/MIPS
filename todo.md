# 摘要：
记录了开发的心得。学习的知识


# 优化


## task 用法：留给regfile 初始化


``` verilog
\\ 计划用task实现、
 // 存储器初始化（示例）
    initial begin
        $readmemh("code.txt", regArr_im); // 从文件加载指令
    end
```


## 几个复位信号的命名
rst_regFile
rst_dataMem
rst_im
rst_pc

使用NPC处理Jump， beq的extend


# verilog语法，技巧

## 永远混乱的input output
输入类型一定是wire
输出类型可以是reg。 
testbench, 输入常为reg 输出常是wire

## 易错的array语法
lw sw 1KB 使用 256 * 32 最好

## assign 用法：
不能用在block（if else, always）
用于给wire 且是 output赋值 中间wire变量由组合电路驱动不需要用assign

## top module 实例化
只要不是input中存在的，就要定义。而且是wire类型

## testbench 实例化
unt的输入需要用reg类型提前声明。
unt的输出用wire类型提前声明。

## timescale
``timescale 1ns/1ps` 后者是精度time precision。前者是时间间隔time unit

可以在设计模块使用时间设置命令和延迟命令。

## integer类型的用法
似乎不可以在block创建。。。

## 在tb访问子模块
暂时不学

## testbench
1. 为什么tb module不需要和design module那样有input output?
2. 为什么tb 内实例化测试模块时input传入reg类型，output传入wire类型？

答：
1. 很好理解，因为tb是单独的模块，不需要向外部开放端口
2. verilog reg类型是可以变化的量。而wire不可以。你不可以改变wire类型，你只能设计一个关系让他跟着某个东西变。

## verilog最重要的几句话
assign用于combinational logic
always -> sequential logic




## 系统命令
`dumpfile` 告诉仿真器保存波形文件的文件名. 用于创建vcd文件。
`dumpvar` 指定仿真时写进vcd波形文件的信号。决定把那些信号写入vcd file.这将是你在gtkwave看到的信号。 

`$dumpvars(2, [top_module_name]);`囊括：顶层，子模块、子子模块的信号
- 数字0表示层级，使用0只关注top这一层。
- 直接用`dumpvars` 不仅关注顶层模块的信号，还会包含所有的子模块、子子模块....的信号。

## block
initial , always 块可以并行执行

## 文件名常识
.vcd file  gtkwave /path/to/vcdfile
.vvp file  iverilog编译产物，放在/build中.  
vcd file is generated by vvp command from vvp file

# 自动化 习惯
1. Makefile比task.json正规。因此，发布包含Makefile会更加正规。 当然，也可以发布task.json
2. 每次push之前要运行一次！！！检查&消除所有的语法错误！！！



